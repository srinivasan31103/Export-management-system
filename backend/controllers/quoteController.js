import { Quote, Buyer } from '../models/index.js';
import { calculateLandedCost } from '../utils/pricingUtil.js';
import { createAuditLog } from '../utils/auditLogger.js';

/**
 * POST /api/quotes
 * Create a quotation
 */
export const createQuote = async (req, res, next) => {
  try {
    const {
      buyerId,
      originPort,
      destinationPort,
      modeOfTransport,
      incoterm,
      weightKg,
      volumeCbm,
      freightCost,
      insuranceCost,
      customsDuty,
      handlingCharges,
      markupPercent,
      currency,
      validityDate,
      notes
    } = req.body;

    const buyer = await Buyer.findById(buyerId);
    if (!buyer) {
      return res.status(404).json({
        success: false,
        error: 'Buyer not found'
      });
    }

    const quote = await Quote.create({
      quote_no: '', // Will be auto-generated by pre-save hook
      buyer_id: buyerId,
      origin_port: originPort,
      destination_port: destinationPort,
      mode_of_transport: modeOfTransport || 'sea',
      incoterm: incoterm || 'FOB',
      weight_kg: weightKg,
      volume_cbm: volumeCbm,
      freight_cost: freightCost || 0,
      insurance_cost: insuranceCost || 0,
      customs_duty: customsDuty || 0,
      handling_charges: handlingCharges || 0,
      markup_percent: markupPercent || 0,
      currency: currency || 'USD',
      validity_date: validityDate,
      status: 'draft',
      notes
    });

    await createAuditLog({
      userId: req.user.id,
      action: 'create_quote',
      entityType: 'quote',
      entityId: quote._id,
      ipAddress: req.ip,
      userAgent: req.get('user-agent')
    });

    res.status(201).json({
      success: true,
      data: quote
    });
  } catch (error) {
    next(error);
  }
};

/**
 * GET /api/quotes/:id
 * Get single quote by ID
 */
export const getQuote = async (req, res, next) => {
  try {
    const quote = await Quote.findById(req.params.id)
      .populate('buyer_id', 'name company_name');

    if (!quote) {
      return res.status(404).json({
        success: false,
        error: 'Quote not found'
      });
    }

    res.json({
      success: true,
      data: quote
    });
  } catch (error) {
    next(error);
  }
};

/**
 * GET /api/quotes
 * Get all quotes
 */
export const getQuotes = async (req, res, next) => {
  try {
    const { page = 1, limit = 20, buyerId, status } = req.query;

    const query = {};
    if (buyerId) query.buyer_id = buyerId;
    if (status) query.status = status;

    const skip = (page - 1) * limit;

    const [quotes, count] = await Promise.all([
      Quote.find(query)
        .populate('buyer_id', 'name company_name')
        .limit(parseInt(limit))
        .skip(parseInt(skip))
        .sort({ createdAt: -1 })
        .lean(),
      Quote.countDocuments(query)
    ]);

    res.json({
      success: true,
      data: {
        quotes,
        pagination: {
          total: count,
          page: parseInt(page),
          pages: Math.ceil(count / limit)
        }
      }
    });
  } catch (error) {
    next(error);
  }
};

/**
 * PUT /api/quotes/:id
 * Update a quote
 */
export const updateQuote = async (req, res, next) => {
  try {
    const {
      buyerId,
      originPort,
      destinationPort,
      modeOfTransport,
      incoterm,
      weightKg,
      volumeCbm,
      freightCost,
      insuranceCost,
      customsDuty,
      handlingCharges,
      markupPercent,
      currency,
      validityDate,
      status,
      notes
    } = req.body;

    const quote = await Quote.findById(req.params.id);
    if (!quote) {
      return res.status(404).json({
        success: false,
        error: 'Quote not found'
      });
    }

    // Update fields
    if (buyerId) quote.buyer_id = buyerId;
    if (originPort) quote.origin_port = originPort;
    if (destinationPort) quote.destination_port = destinationPort;
    if (modeOfTransport) quote.mode_of_transport = modeOfTransport;
    if (incoterm) quote.incoterm = incoterm;
    if (weightKg !== undefined) quote.weight_kg = weightKg;
    if (volumeCbm !== undefined) quote.volume_cbm = volumeCbm;
    if (freightCost !== undefined) quote.freight_cost = freightCost;
    if (insuranceCost !== undefined) quote.insurance_cost = insuranceCost;
    if (customsDuty !== undefined) quote.customs_duty = customsDuty;
    if (handlingCharges !== undefined) quote.handling_charges = handlingCharges;
    if (markupPercent !== undefined) quote.markup_percent = markupPercent;
    if (currency) quote.currency = currency;
    if (validityDate) quote.validity_date = validityDate;
    if (status) quote.status = status;
    if (notes !== undefined) quote.notes = notes;

    await quote.save();

    await createAuditLog({
      userId: req.user.id,
      action: 'update_quote',
      entityType: 'quote',
      entityId: quote._id,
      ipAddress: req.ip,
      userAgent: req.get('user-agent')
    });

    res.json({
      success: true,
      data: quote
    });
  } catch (error) {
    next(error);
  }
};

/**
 * DELETE /api/quotes/:id
 * Delete a quote
 */
export const deleteQuote = async (req, res, next) => {
  try {
    const quote = await Quote.findById(req.params.id);
    if (!quote) {
      return res.status(404).json({
        success: false,
        error: 'Quote not found'
      });
    }

    await quote.deleteOne();

    await createAuditLog({
      userId: req.user.id,
      action: 'delete_quote',
      entityType: 'quote',
      entityId: quote._id,
      ipAddress: req.ip,
      userAgent: req.get('user-agent')
    });

    res.json({
      success: true,
      data: {}
    });
  } catch (error) {
    next(error);
  }
};

/**
 * POST /api/quotes/landed-cost
 * Calculate landed cost for a shipment
 */
export const calculateLanded = async (req, res, next) => {
  try {
    const {
      productValue,
      freightCost,
      insurancePercent,
      customsDutyPercent,
      handlingFee,
      originCountry,
      destinationCountry
    } = req.body;

    const result = calculateLandedCost({
      productValue: parseFloat(productValue),
      freightCost: parseFloat(freightCost),
      insurancePercent: parseFloat(insurancePercent || 2),
      customsDutyPercent: parseFloat(customsDutyPercent || 10),
      handlingFee: parseFloat(handlingFee || 0),
      originCountry,
      destinationCountry
    });

    res.json({
      success: true,
      data: result
    });
  } catch (error) {
    next(error);
  }
};

export default {
  createQuote,
  getQuote,
  getQuotes,
  updateQuote,
  deleteQuote,
  calculateLanded
};
